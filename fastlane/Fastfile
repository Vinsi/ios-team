require 'yaml'

fastlane_version "1.70.0"

default_platform :ios

platform :ios do

  ######################### PUBLIC UTILITIES ##########################

  lane :setup_new_release do |options|

    develop_branch = options['develop_branch']
    xcodeproject = options['xcodeproject']
    github_remote = options['github_remote']

    possible_upcoming_versions = ["patch", "minor", "major"]
    possible_versions_indexes = ["1", "2", "3"]
    upcoming_version = prompt(text: "You must provide a new version to set. Available:
    1) #{possible_upcoming_versions[0]}
    2) #{possible_upcoming_versions[1]}
    3) #{possible_upcoming_versions[2]}")

    if possible_versions_indexes.include? upcoming_version
      increment_version_number(
        bump_type: possible_upcoming_versions[upcoming_version.to_i - 1]
      )
    elsif possible_upcoming_versions.include? upcoming_version
      increment_version_number(
        bump_type: upcoming_version
      )
    else
      possible_inputs = ["1", "2", "3", possible_upcoming_versions[0], possible_upcoming_versions[1], possible_upcoming_versions[2]]
      puts "Incorrect new upcoming version. Possible inputs: #{possible_inputs.to_s}"
    end

    new_upcoming_version = get_version_number(
      xcodeproj: xcodeproject
    )

    commit_version_bump message: "Bump version to #{new_upcoming_version}."

    remote = github_remote
    push_to_git_remote(
      remote: remote,
      local_branch: develop_branch,
      remote_branch: develop_branch
    )

    changelog_data = get_changelog_data
    changelog_data["upcoming"]["version"] = new_upcoming_version
    save_changelog_data(
      changelog_data: changelog_data
    )
  end

  lane :put_upcoming_to_releases do
    changelog_data = get_changelog_data
    upcoming = changelog_data["upcoming"].clone
    changelog_data["upcoming"]["version"] = nil
    changelog_data["upcoming"]["notes"] = nil
    if changelog_data["releases"].count > 0
      changelog_data["releases"].unshift(upcoming)
    else
      changelog_data["releases"].push(upcoming)
    end
    save_changelog_data(
      changelog_data: changelog_data
    )
    git_commit_shell(
      message: "Move upcoming version to releases in CHANGELOG"
    )
  end

  lane :get_changelog_data do
    changelog_data = YAML.load(File.open "../CHANGELOG.yml")
    changelog_data
  end

  lane :save_changelog_data do |options|
    changelog_data = options[:changelog_data]
    File.open("../CHANGELOG.yml", 'w') { |f| YAML.dump(changelog_data, f) }
  end

  lane :get_releases do
    changelog_data = get_changelog_data
    releases = changelog_data["releases"]
    releases
  end

  lane :get_upcoming do
    changelog_data = get_changelog_data
    upcoming = changelog_data["upcoming"]
    upcoming
  end

  lane :get_upcoming_version do
    upcoming = get_upcoming
    upcoming_version = upcoming["version"]
    upcoming_version
  end

  lane :get_upcoming_notes do
    upcoming = get_upcoming
    upcoming_notes =  "* #{upcoming["notes"].join "\n* "} \n\n"
    upcoming_notes
  end

  lane :git_commit_shell do |options|
    message = options[:message]
    sh("git commit -am '#{message}'")
  end

  lane :git_merge_branch do |options|
    source_branch = options[:source_branch]
    sh("git merge #{source_branch}")
  end

  lane :git_checkout_branch do |options|
    destination_branch = options[:destination_branch]
    sh("git checkout #{destination_branch}")
  end

  lane :git_branch_exists_on_remote do |options|
    remote = options[:remote]
    branch = options[:branch]
    branch_exist = sh("git ls-remote --heads #{remote} #{branch} | wc -l")
    branch_exist
  end

  lane :git_add_or_update_tag do |options|
    tag_name = options[:tag_name]
    remote = options[:remote]
    branch = options[:branch]

    branch_exist = git_branch_exists_on_remote(
      remote: remote,
      branch: branch
    )

    if branch_exist.to_i != 0
      sh("git pull #{remote} #{branch} --tags")
    end

    if git_tag_exists(tag: tag_name)
      sh("git tag #{tag_name} -d")
      sh("git push #{remote} :refs/tags/#{tag_name}")
    end

    sh("git tag #{tag_name}")
    sh("git push #{remote} --tags")
  end

  lane :set_or_update_github_release do |options|
    release_name = options[:release_name]
    description = options[:description]
    repository_name = options[:repository_name]
    tag_name = options[:tag_name]
    api_token = options[:api_token]
    upload_asset = options[:upload_asset]

    release = get_github_release(
      url: repository_name,
      version: release_name,
      api_token: api_token
    )

    if release != nil
      release_id = release['id'].to_s
      edit_github_release(
        repository_name: repository_name,
        id: release_id,
        description: description,
        tag_name: tag_name,
        name: release_name,
        api_token: api_token
      )
      if upload_assets.count > 0
        upload_url = release['upload_url']
        upload_asset_for_github_release(
          file_path: upload_asset,
          upload_url_template: upload_url
        )
      end
    else
      set_github_release(
        repository_name: repository_name,
        api_token: api_token,
        name: release_name,
        tag_name: tag_name,
        description: description,
        upload_assets: upload_asset ? [upload_asset] : []
      )
    end
  end

end
